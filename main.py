import os
import logging
from mcp.server.fastmcp import FastMCP
from dotenv import load_dotenv

# Import helper modules
from utils.github_api import create_github_repository
from utils.git_operations import (
    clone_template_to_base_directory,
    generate_commit_message,
    push_to_github,
    create_file_in_project,
    commit_and_push_changes
)
from utils.file_handling import (
    read_file,
    list_files as list_files_in_directory,
    update_file,
)

load_dotenv()

# --- Configuration & Constants ---

# Initialize FastMCP server
mcp = FastMCP("website-generator")

# Template Repository
TEMPLATE_REPO = "https://github.com/Jeetanshu18/react-vite"

# Get GitHub token
GITHUB_TOKEN = os.getenv("GITHUB_TOKEN")

if not GITHUB_TOKEN:
    logging.warning("GITHUB_TOKEN environment variable not set.")


@mcp.tool()
async def repo_setup(
    project_name: str,
    description: str = "",
    deploy_to_amplify: bool = False,
) -> str:
    """
    Setup a new repository for a website project by cloning a template, creating a GitHub repo, and pushing the code.

    This tool performs the following steps:
    1. Clone the React Vite template repository directly to base directory
    2. Remove the .git folder from the cloned repository
    3. Create a new repository on GitHub with the given project name
    4. Push the code to the new GitHub repository
    5. Optionally deploy to AWS Amplify (if requested)

    Args:
        project_name: Name of the project and GitHub repository
        description: Optional description for the GitHub repository
        deploy_to_amplify: Whether to deploy to AWS Amplify (optional, not implemented yet)

    Returns:
        Status message with repository URL and deployment information
    """
    # Check for token at function call time
    github_token = os.getenv("GITHUB_TOKEN")
    if not github_token:
        return "GitHub Token is missing. Cannot process repository setup requests."

    if not project_name or not project_name.strip():
        return "Project name is required and cannot be empty."

    # Sanitize project name for GitHub
    project_name = project_name.strip().replace(" ", "-").lower()

    try:
        logging.info(f"Starting repository setup for project: {project_name}")

        # Step 1: Clone template repository directly to base directory
        logging.info("Step 1: Cloning template repository to base directory...")
        base_directory = "."
        success, project_path = await clone_template_to_base_directory(
            project_name, base_directory, TEMPLATE_REPO
        )
        if not success:
            return f"Failed at Step 1: {project_path}"

        # Step 2: Create GitHub repository
        logging.info("Step 2: Creating GitHub repository...")
        success, repo_url = await create_github_repository(project_name, description)
        if not success:
            return f"Failed at Step 2: {repo_url}"

        # Step 3: Push to GitHub
        logging.info("Step 3: Pushing code to GitHub...")
        success, message = await push_to_github(project_path, repo_url, project_name)
        if not success:
            return f"Failed at Step 3: {message}"

        # Prepare success message
        result_message = f"""
Repository setup completed successfully!

Project Name: {project_name}
Repository URL: {repo_url.replace('.git', '')}
Template Used: {TEMPLATE_REPO}
Local Directory: ./{project_name}

Steps Completed:
✅ Cloned React Vite template repository to base directory
✅ Removed .git folder from template
✅ Created new GitHub repository
✅ Pushed code to GitHub repository

Your website project is now ready for local development!

Local Development Setup:
1. Navigate to project: cd {project_name}
2. Install dependencies: npm install
3. Start development server: npm run dev
4. Build for production: npm run build

Repository Management:
- Use push_changes tool to commit and push your changes
- Project is already set up with git and connected to GitHub
        """

        # Step 4: Optional Amplify deployment
        if deploy_to_amplify:
            result_message += "\n⚠️  AWS Amplify deployment is not yet implemented but can be added in future updates."

        return result_message.strip()

    except Exception as e:
        logging.error(f"Unexpected error during repository setup: {str(e)}")
        return f"Repository setup failed due to unexpected error: {str(e)}"


@mcp.tool()
async def create_file(file_name: str, file_path: str, content: str) -> str:
    """
    Create a new file in the project with content generated by the AI Agent.

    This tool performs the following steps:
    1. Get the file_name, file_path and content from the AI Agent
    2. Create a new file with the given file_name at the file_path
    3. Write the content in the file

    Args:
        file_name: Name of the file to create (e.g., "index.html", "app.js")
        file_path: Directory path where the file should be created (e.g., "./src", "./public")
        content: Content to write to the file

    Returns:
        Status message indicating success or failure
    """
    if not file_name or not file_name.strip():
        return "File name is required and cannot be empty."

    if not file_path or not file_path.strip():
        return "File path is required and cannot be empty."

    if content is None:
        content = ""  # Allow empty files

    try:
        logging.info(f"Creating file: {file_name} at path: {file_path}")

        # Create the file
        success, message = await create_file_in_project(file_path, file_name, content)

        if success:
            result_message = f"""
File created successfully!

File Name: {file_name}
File Path: {file_path}
Content Length: {len(content)} characters

✅ File '{file_name}' has been created at '{file_path}'

The file is ready for use in your project.
"""
            return result_message.strip()
        else:
            return f"Failed to create file: {message}"

    except Exception as e:
        logging.error(f"Unexpected error during file creation: {str(e)}")
        return f"File creation failed due to unexpected error: {str(e)}"


@mcp.tool()
async def push_changes(project_name: str) -> str:
    """
    Commit the changes made to the project and push them to the remote repository.

    This tool performs the following steps:
    1. Get the project name from the AI Agent
    2. Locate the project directory in the base directory
    3. Check if there are any changes made to the project
    4. If there are no changes, it will return
    5. If there are changes, it will stage the changes
    6. Commit the changes with an auto-generated commit message
    7. Push the changes to the remote repository

    Args:
        project_name: Name of the project (same as used in repo_setup)

    Returns:
        Status message indicating success or failure
    """
    if not project_name or not project_name.strip():
        return "Project name is required and cannot be empty."

    # Sanitize inputs and generate commit message
    project_name = project_name.strip().replace(" ", "-").lower()
    commit_message = generate_commit_message()

    # Construct project path
    project_path = f"./{project_name}"

    # Check if project directory exists
    if not os.path.exists(project_path):
        return f"Project directory '{project_path}' not found. Make sure the project was created using repo_setup first."

    # Check if it's a git repository
    git_dir = os.path.join(project_path, ".git")
    if not os.path.exists(git_dir):
        return f"Project directory '{project_path}' is not a git repository. Make sure the project was created using repo_setup first."

    try:
        logging.info(
            f"Pushing changes for project '{project_name}' with auto-generated message: {commit_message}"
        )

        # Commit and push changes
        success, message = await commit_and_push_changes(project_path, commit_message)

        if success:
            if "No changes to commit" in message:
                result_message = f"""
No changes detected in the project.

Project Name: {project_name}
Project Path: {project_path}
Status: No changes to commit

ℹ️  The project is already up to date with the remote repository.
"""
            else:
                result_message = f"""
Changes committed and pushed successfully!

Project Name: {project_name}
Project Path: {project_path}
Auto-Generated Commit Message: {commit_message}

Steps Completed:
✅ Located project directory: {project_path}
✅ Verified git repository structure
✅ Checked for changes in the project
✅ Staged all changes
✅ Committed changes with auto-generated message
✅ Pushed changes to the remote repository

Your changes are now live in the remote repository!
"""
            return result_message.strip()
        else:
            return f"Failed to push changes: {message}"

    except Exception as e:
        logging.error(f"Unexpected error during push operation: {str(e)}")
        return f"Push operation failed due to unexpected error: {str(e)}"


@mcp.tool()
async def read_file(file_path: str) -> str:
    """
    Read the contents of a file.

    This tool allows reading the contents of any file in the project or system.
    Useful for examining configuration files, source code, or any text-based files.

    Args:
        file_path: Path to the file to read (can be relative or absolute)

    Returns:
        File contents or error message
    """
    if not file_path or not file_path.strip():
        return "File path is required and cannot be empty."

    try:
        logging.info(f"Reading file: {file_path}")
        success, content = await read_file(file_path)

        if success:
            return f"""
File read successfully!

File Path: {file_path}
Content Length: {len(content)} characters
Lines: {len(content.splitlines())}

--- File Content ---
{content}
--- End of File ---
"""
        else:
            return f"Failed to read file: {content}"

    except Exception as e:
        logging.error(f"Unexpected error reading file: {str(e)}")
        return f"File read failed due to unexpected error: {str(e)}"


@mcp.tool()
async def list_files(directory_path: str) -> str:
    """
    List all files and directories in the specified directory.

    This tool provides a directory listing showing files and subdirectories.
    Files are marked with [FILE] and directories with [DIR] prefixes.

    Args:
        directory_path: Path to the directory to list (can be relative or absolute)

    Returns:
        Directory listing or error message
    """
    if not directory_path or not directory_path.strip():
        return "Directory path is required and cannot be empty."

    try:
        logging.info(f"Listing directory: {directory_path}")
        success, items = await list_files_in_directory(directory_path)

        if success:
            if not items:
                return f"""
Directory listing completed!

Directory Path: {directory_path}
Status: Directory is empty

No files or subdirectories found.
"""
            else:
                items_str = "\n".join(items)
                return f"""
Directory listing completed!

Directory Path: {directory_path}
Total Items: {len(items)}

--- Directory Contents ---
{items_str}
--- End of Listing ---
"""
        else:
            return f"Failed to list directory: {items}"

    except Exception as e:
        logging.error(f"Unexpected error listing directory: {str(e)}")
        return f"Directory listing failed due to unexpected error: {str(e)}"


@mcp.tool()
async def update_file(file_path: str, new_content: str) -> str:
    """
    Update the contents of an existing file.

    This tool overwrites the entire content of an existing file with new content.
    The file must already exist - use create_file to create new files.

    Args:
        file_path: Path to the file to update (can be relative or absolute)
        new_content: New content to write to the file

    Returns:
        Success message or error message
    """
    if not file_path or not file_path.strip():
        return "File path is required and cannot be empty."

    if new_content is None:
        new_content = ""  # Allow empty content

    try:
        logging.info(f"Updating file: {file_path}")
        success, message = await update_file(file_path, new_content)

        if success:
            return f"""
File updated successfully!

File Path: {file_path}
Content Length: {len(new_content)} characters
Lines: {len(new_content.splitlines())}

✅ File '{file_path}' has been updated with new content.

The file is ready for use in your project.
"""
        else:
            return f"Failed to update file: {message}"

    except Exception as e:
        logging.error(f"Unexpected error updating file: {str(e)}")
        return f"File update failed due to unexpected error: {str(e)}"


if __name__ == "__main__":
    # Configure logging
    logging.basicConfig(
        level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
    )

    # Check for GitHub Token at startup
    if not GITHUB_TOKEN:
        logging.critical(
            "GITHUB_TOKEN is not set. The server cannot communicate with GitHub API."
        )
        logging.info(
            "Please set the GITHUB_TOKEN environment variable with a valid GitHub personal access token."
        )
        # Note: We don't exit here to allow the server to start, but operations will fail

    # Initialize and run the server
    mcp.run(transport="stdio")
